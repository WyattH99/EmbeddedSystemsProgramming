/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


// Enable all configurable fault exceptions, Implement the fault exception handlers, and
// cause the fault
int main(void)
{

	// 1. Enable all configurable exceptions like Usage, Memory Management, and Bus Faults

	uint32_t *pSHCSR = (uint32_t*)0xE000ED24; // Address for System Handler Control and State Register
	*pSHCSR |= (1 << 18); // Enable Usage Fault bit 18
	*pSHCSR |= (1 << 17); // Enable Bus Fault bit 17
	*pSHCSR |= (1 << 16); // Enable Memory Management Fault bit 16


	// 3. Force the Processor to execute an Undefined Instruction
	// Store an Undefined Instruction in SRAM
	// Execute it by calling a pointer to it

	uint32_t *pSRAM = (uint32_t*) 0x20010000; // Random Memory Location
	*pSRAM = 0xFFFFFFFF; // Undefined Instruction

	void (*some_address) (void); // Function pointer

	some_address = (void*) (((uint32_t)pSRAM)+1); // Initializing the Function Pointer to point at the Undefined Instruction
	// The address of a function must be odd (end in 1) for the TBit to stay in Thumb Instruction Set

	some_address(); // Dereference the Function Pointer to get the PC to be loaded with the Undefined Instruction


	// 4. Analyze the Fault




    /* Loop forever */
	for(;;);
}


// 2. Implement Fault Handlers
// Get the Handler names from the Vector Table ("g_pfnVectors:") in the Startup file

void HardFault_Handler(void){
	printf("Exception: HardFault\n");
	while(1);
}


// To Analyze the Stack Frame you have to avoid the Epilogue of a normal C Function
__attribute__ ((naked)) void UsageFault_Handler(void){
	__asm ("MRS r0,MSP"); // Store the Main Stack Pointer into r0
	__asm ("B UsageFault_Handler_c");
}

void UsageFault_Handler_c(void){

	// Analyze the Stack frame
	__asm ("MRS r0,MSP"); // Store the Main Stack Pointer into r0
	register uint32_t msp_value __asm("r0"); // Store r0 into a variable in a register
	uint32_t *pMSP = (uint32_t*)msp_value; // Initialize a pointer to the

	printf("Exception: UsageFault\n");

	// Check the Usage Fault State Register
	uint32_t *pUSFR = (uint32_t*)0xE000ED2A;
	printf("UFSR: %lx\n", (*pUSFR) & 0xFFFF); // The USFR is 16bits wide

	printf("MSP: %p\n", pMSP);

	while(1);
}


void MemManage_Handler(void){
	printf("Exception: MemMangeFault\n");
	while(1);
}


void BusFault_Handler(void){
	printf("Exception: BusFault\n");
	while(1);
}






