/*
 * main-1.c
 *
 *  Created on: Jan 15, 2024
 *      Author: wyatt
 */


/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


int fun_divide(int x, int y){return x/y;}


// Enable all configurable fault exceptions, Implement the fault exception handlers, and
// cause the fault
int main(void)
{

	// 1. Enable all configurable exceptions like Usage, Memory Management, and Bus Faults

	uint32_t *pSHCSR = (uint32_t*)0xE000ED24; // Address for System Handler Control and State Register
	*pSHCSR |= (1 << 18); // Enable Usage Fault bit 18
	*pSHCSR |= (1 << 17); // Enable Bus Fault bit 17
	*pSHCSR |= (1 << 16); // Enable Memory Management Fault bit 16


	// Enable divide by 0 trap on the 4th bit of Address of Configuration and Control Register
	uint32_t *pCCR = (uint32_t*)0xE000ED14; // Address of Configuration and Control Register
	*pCCR |= (1 << 4);

	fun_divide(10,0);

    /* Loop forever */
	for(;;);
}


// 2. Implement Fault Handlers
// Get the Handler names from the Vector Table ("g_pfnVectors:") in the Startup file

void HardFault_Handler(void){
	printf("Exception: HardFault\n");
	while(1);
}


// To Analyze the Stack Frame you have to avoid the Epilogue of a normal C Function so naked is used
__attribute__ ((naked)) void UsageFault_Handler(void){
	__asm ("MRS r0,MSP"); // Store the Main Stack Pointer into r0
	__asm ("B UsageFault_Handler_c"); // Branch into the UsaageFault_Handler with out changing the MSP
}

// The value of r0 from the naked function will be captured into the variable
void UsageFault_Handler_c(uint32_t *pBaseStackFrame){

	// Analyze the Stack frame
	// Don't need this code to analyze the Stack
//	__asm ("MRS r0,MSP"); // Store the Main Stack Pointer into r0
//	register uint32_t msp_value __asm("r0"); // Store r0 into a variable in a register
//	uint32_t *pMSP = (uint32_t*)msp_value; // Initialize a pointer to the

	printf("Exception: UsageFault\n");

	// Check the Usage Fault State Register
	uint32_t *pUSFR = (uint32_t*)0xE000ED2A;
	printf("UFSR: %lx\n", (*pUSFR) & 0xFFFF); // The USFR is 16bits wide

	printf("pBaseStackFrame: %p\n", pBaseStackFrame);

	// Now that we have the address of the Stack Frame we can Analyze the Frame by printing them
	printf("Value of R0 = %lx\n", pBaseStackFrame[0]);
	printf("Value of R1 = %lx\n", pBaseStackFrame[1]);
	printf("Value of R2 = %lx\n", pBaseStackFrame[2]);
	printf("Value of R3 = %lx\n", pBaseStackFrame[3]);
	printf("Value of R12 = %lx\n", pBaseStackFrame[4]);
	printf("Value of LR = %lx\n", pBaseStackFrame[5]);
	printf("Value of PC = %lx\n", pBaseStackFrame[6]);
	printf("Value of XPSR = %lx\n", pBaseStackFrame[7]);

	while(1);
}


void MemManage_Handler(void){
	printf("Exception: MemMangeFault\n");
	while(1);
}


void BusFault_Handler(void){
	printf("Exception: BusFault\n");
	while(1);
}






